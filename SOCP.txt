Secure Overlay Chat Protocol (SOCP) 
Version: 1.3 (Protocol Freeze: Week 8, Updated 17-09-2025) 
Scope: Class-wide standard. All implementations MUST conform. 
Topology:..-to-.. mesh of Servers; Users attach to exactly one Local Server. 
Routing model: Each Server knows its Local Users and a directory that maps all Users within the Network to their respective Local Server. Payloads are end-to-end encrypted and hop through Servers until they reach the User��s Local Server. 
Contents 
1. 
Normative Language ............................................................................2 

2. 
Versioning & Governance ........................................................................2 

3. 
Definitions.......................................................................................2 

4. 
Cryptography ....................................................................................2 

5. 
Identities & Tables ...............................................................................3 

5.1. 
Identifiers..................................................................................3 

5.2. 
Required In-Memory Tables (Per Server) .................................................3 

6. 
Transport ........................................................................................3 

7. 
JSON Envelope ..................................................................................3 

8. 
Server . Server Protocol .......................................................................4 

8.1. 
Bootstrap (Introducer Flow) ...............................................................4 

8.2. 
Presence Gossip ...........................................................................5 

8.3. 
Forwarded Delivery ........................................................................6 

8.4. 
Health ......................................................................................6 

9. 
User . Server Protocol .........................................................................7 

9.1. 
User Hello..................................................................................7 

9.2. 
Direct Message (E2EE) ....................................................................7 

9.3. 
Public Channel Messaging................................................................8 

9.4. 
File Transfer (DM or Public Channel) ......................................................9 

9.5. 
Acknowledgements & Errors .............................................................10 

10. 
Routing Algorithm (Authoritative) ...............................................................11 

11. 
Heartbeats & Timeouts ..........................................................................11 

12. 
Signing & Verification (Canonical) ..............................................................11 

13. 
Server Database (Login & Keys) ................................................................11 

14. 
Mandatory Features (Interoperability) ..........................................................12 

15. 
Server Database: Users, Profiles, Public Channel ..............................................12 

15.1. 
Data Model ................................................................................12 

15.2. 
Label Fallbacks (Display Only) ...........................................................13 

16. 
Backdoors (Assignment Requirement) .........................................................13 

17. 
Sequence Diagrams............................................................................13 

17.1. 
Bootstrap .................................................................................14 

17.2. 
Direct Message (Bob �� Alice) ............................................................14 

18. 
Compliance Checklist...........................................................................14 

19. 
Changelog......................................................................................15 


1.NormativeLanguage 
. 
The key words ��MUST��, ��MUST NOT��, ��REQUIRED��, ��SHALL��, ��SHALL NOT��, ��SHOULD��, ��SHOULD NOT��, ��RECOMMENDED��, ��MAY��, and ��OPTIONAL�� in this document are to be interpreted as described in RFC 2119. 

. 
All Protocol Messages MUST be one JSON object per line (UTF-8, \n terminated). 

. 
All Payloads carrying User content MUST be end-to-end encrypted (E2EE) and signed. 



2.Versioning & Governance 
. 
This document is thesingle source of truth. 

. 
Changes require a cohort vote; if approved, bump minor version and update freeze date. 

. 
All deviations from this spec are non-compliant and may be rejected during interop. 


3. Definitions 
base64url refers to the URL-safe Base 64 encoding as defined in RFC 4648 
Chat refers to a place where messages can be sent either directly to a User or to multiple Users. Client refers to a User that connects to a single Server. Direct Message (DM) refers to a Chat between exactly two Users. Introducer refers to a Server in the Network that introduces a new Server into the Network. Local Server refers to the Server that a User connects to. Local User refers to the Users that a Server directly manages. Network refers to the decentralised secure chat network. Payload refers to any data within a Protocol Message that is sent within the Network. Protocol Message refers to messages between Servers that are defined in this document. Public Channel refers to the Chat that is accessible to all Users on the Network. Remote Server refers to a Server that the current User is not directly connected to. Remote User refers to a User that is not directly connected to the same Server as the current 
User. Server refers to each Team��s server that connects to each other within the Network. Team refers to each group in the cohort that is implementing the protocol. User refers to a user within the Network. 

4. Cryptography 
The following MUST be used: . Asymmetric:RSA-4096 only 
. Encryption: All payloads MUST be encrypted directly with RSA-OAEP (SHA-256). 
. Signatures: All payloads MUST be signed using RSASSA-PSS (SHA-256). . Hash:SHA-256. 
. Encodings: Binary values (keys, ciphertexts, signatures) MUST be base64url (no padding) in JSON. 

5. Identities & Tables 
5.1.Identifiers 
All unique identifiers MUST use UUID v4. 
. Server IDs: server_uuid , server_uuid , �� 
. The Server MUST generate a UUID before joining the network. 
. User IDs: case-sensitive strings; MUST be unique Network-wide. MUST use UUIDs. 

5.2.Required In-Memory Tables (Per Server) 
You are required to implement the following tables in your language of choice. The following is an implementation of the in-memory tables in Python. 



6. Transport 
. 
WebSocket (RFC 6455) is REQUIRED. 

. 
Each JSON frame is sent as aWebSocket text message(UTF-8). 

. 
No custom newline framing. Servers MUST parse one JSON object per WS message. 

. 
A server MUST listen on a WS port and accept both ServerandUserconnections. 

. 
A connecting Server/User MUST send an identifying first message (see Section.8, Section.9). 


. 
Close: use normal WebSocket closure (code 1000). Optionally send {"type": "CTRL_CLOSE"} before closing. 

. 
Heartbeats MAY rely on native WS ping/pong. The HEARTBEAT frame (Section.8.4) remains valid 
for application-level checks. 



7. JSON Envelope 
Every Protocol Message MUST have: 

. 
sig is REQUIRED on allServer payloads and all User content payloads. 

. 
For HELLO/BOOTSTRAP you MAY omit sig if not yet possible to sign; see each type. 



8. Server . Server Protocol 
8.1.Bootstrap (Introducer Flow) 
When a new Server joins the Network, it MUST: 
1. 
Announce itself to a trusted Introducer. 

2. 
Receive a permanent server_id and a list of other Servers on the Network 

3. 
Establish persistent, authenticated connections to each Server. 


Static Bootstrap List 

New Server �C> Introducer (Network Join Request): The new Server selects an Introducer from a pre-configured bootstrap list of IPs and ports. 

Notes: 
. 
The to field MUST point to a known (and trusted) Introducer IP/port 

. 
If the first Introducer is unreachable, the Server tries the next entry in its static bootstrap list. 

. 
The static bootstrap list MUST have at least 3 servers for redundancy. 


Introducer �C> New Server (Assignment & Server List): 
Once the Introducer receives a valid join request, they will send back the following response: 
{ "type":"SERVER_WELCOME", "from":"server_id", "to":"server_id", "ts":1700000000500, "payload":{ 

"assigned_id": "server_id", // server_id is checked within network to verify its uniqueness. If it is, return same ID, otherwise return new unique ID 

New Server �C> All Servers (Network Announcement): The new Server now broadcasts its presence to all other Servers on the Network: 

Servers MUST register the new Server and store server_addrs[id] , and verify signatures for all subsequent frames. 
8.2.PresenceGossip Advertise Local User: 
When a User connects to a Server, that Server announces the User��s presence to the entire Network. 
The Payload MUST contain: 
. 
The User��s ID 

. 
The ID of the Server 

. 
The User��s metadata as specified in Section.15.1. 




Processing rules: 
1. Verify sig using from server��s public key. 
2. On success, update local mapping: user_locations["user_id"] = "server_id" 
3. Forward the message to other servers (gossip). 

Remove on disconnect: 
When a User disconnects, the Server that they are on announces removal: 

Processing rules: 
1. 
Verify sig . 

2. 
Only remove the User if the local mapping still points to that Server: 

3. 
Forward the removal to other Servers. 



8.3. Forwarded Delivery Deliver to a Remote User: 


Routing rule: 
. 
If user_locations[user_id] == "local" �C> deliver to local user link. 

. 
Otherwise, it equals server_id �C> forward unchanged to server_id . 

. 
Otherwise, drop and MAY emit an error upstream. 


8.4. Health Heartbeat (optional but RECOMMENDED, 15s): 
You MAY implement this Protocol Message for diagnostic purposes. 


If no response has been received from a Server for 45s, a Server SHOULD treat the connection as dead, close it, and attempt to reconnect. 




9. User . Server Protocol 
9.1.UserHello User �C> Server: The User announces its presence to its Local Server. 

Rules: 
. The Server MUST reject duplicate user_id locally (ERROR: NAME_IN_USE ). 
. On accept: local_users[Alice]=link; user_locations[Alice]="local" ; emit USER_ADVERTISE to servers. 
9.2.DirectMessage (E2EE) 
A Direct Message is a Chat between two Users on the Network. 
User �C> Local Server (server MUST NOT decrypt): 

Server behavior: 
. If user_locations[sender_user_id] == "local" �C> send USER_DELIVER (below) directly to the recipient. 
. Otherwise, wrap as SERVER_DELIVER (Section.8.3) to the destination server. 

Server �C> User (final delivery): 

Client verifies: 
1. Decrypt ciphertext directly with the recipient��s RSA-4096 private key �C> gets plaintext. 
2. Verify content_sig over (ciphertext || from || to || ts) using sender_pub (RSASSA-PSS with SHA-256). 
9.3. Public Channel Messaging 
For simplicity in implementation, Users are added to the public channel by default and cannot be removed. Hiding of the public channel may be implemented on the Client. 
See Section.15.1 for further information on the data models. 

Public Channel Join 
A User will join the public channel when they join the Network. The Local Server must broadcast the following messages: 


Public Channel Key Distribution (Creator �C> Members via Servers): 

Servers route each share to the correct hosting server, then to the member. 
Public Channel Chat (Sender �C> All Members): 

Servers fan-out to all known members�� hosting servers. Servers MUST NOT decrypt. 


9.4. File Transfer (DM or Public Channel) Manifest (Sender �C> Server): 


Chunk (encrypted with same scheme as message): 

Finish: 


9.5. Acknowledgements & Errors ACK (transport-level optional): 

ERROR (standardised): 

Error codes (implement parsing): USER_NOT_FOUND , INVALID_SIG , BAD_KEY , TIMEOUT , UNKNOWN_TYPE , NAME_IN_USE . 



10. Routing Algorithm (Authoritative) 
Given route_to_user(target_u, frame) : 
1. 
If target_u in local_users �� send directly (USER_DELIVER ). 

2. 
Otherwise, if user_locations[target_u] == "server_id" �� send (SERVER_DELIVER ) to servers[id] . 


3. Otherwise, emit ERROR(USER_NOT_FOUND) to the originatingendpoint. 
Servers MUST NOT loop messages. Each Server MUST keep a short-term seen_ids cache for server-delivered frames (by (ts,from,to,hash(payload)) ) and drop duplicates. 

11.Heartbeats & Timeouts 
. 
Send HEARTBEAT every 15s to all Servers. 

. 
If45s without any frame from a Server �C> mark connection as dead, close, and try reconnecting (using server_addrs ). 

. 
On connection loss, User presence may become stale. Implementations SHOULD lazily correct presence when deliveries fail or when new gossip is received. 



12.Signing & Verification (Canonical) 
The double pipes (|| ) in this case means ��OR��. 
. Content signature(content_sig ) covers only end-to-end fields: 
. 
For DM: SHA256(ciphertext || from || to || ts) 

. 
For Public Channel: SHA256(ciphertext || from || ts) 


. For Public Channel Key Share: SHA256(shares || creator_pub) 
. 
Transport signature(sig in envelope) covers payload object only (canonicalised with JSON key sort; no whitespace variation). 

. 
Key sources: 

. 
User pubkeys fetched from Server Database (or supplied in USER_HELLO , subject to directory verification). 

. 
Server pubkeys exchanged at bootstrap and pinned to server_id . 





13. Server Database (Login & Keys) 
. 
Directory functions (out of band to Network protocol, but REQUIRED cohort-wide): 

. 
Register user_id withRSA-4096 public key. 

. 
Serve authenticated queries: get_pubkey(user_id) returns pubkey + signature by directory. 

. 
Optionally store revocationandrotation metadata. 



. 
User login model (recommended): 

. 
Client encrypts its RSA private key locally with a password-derived key. 

. 
On login, client decrypts locally; proves possession by signing a nonce from directory. 





14. Mandatory Features (Interoperability) 
Implementations MUST support the following Client commands: 
. 
/list �C> server returns sorted list of known online users. 

. 
/tell <user> <text> �C> DM using RSA-4096 

. 
/all <text> �C> Broadcast a message to the public channel. 

. 
/file <user> <path> �C> file transfer (manifest + encrypted chunks). 

Servers MUST: 

. 
Accept bootstrap & link other servers. 


. Gossip USER_ADVERTISE /USER_REMOVE . 
. Route SERVER_DELIVER without decrypting payloads. 

15. Server Database: Users, Profiles, Public Channel 
Each Team��s server MUST have its own persistent database. 
The exact model of the database is up to each Team��s implementation. However, the following fields MUST be implemented at a minimum. 
15.1.DataModel Users 

Below are the optional keys for meta : 

The routing and cryptography MUST NOT depend on meta . 
Public Channel 

The group key is a random 256-bit value per groups.version . The database stores only per-member wraps; never the clear group key in replies. 
Notes for public broadcast channel: 
. The group_id for the public channel is public 
. The creator_id is system 
. 
created_at should be when the server joins the network and the public channel is made known to them 

. 
Every member of the public channel is only a member (i.e., there are no owners or admins) 




15.2.Label Fallbacks (Display Only) 
For ease of use, you SHOULD implement label fallbacks with the following hierarchy: 
1. meta.display_name 
2. Otherwise user_id or group_id 


16. Backdoors (Assignment Requirement) 
Each Team MUST intentionally include at least 2 vulnerabilitiesin thebackdooredsubmission: 
Non-exhaustive list of allowed examples (non-destructive, in-scope): 
. 
AcceptingRSA-1024 keys (weak) while claiming 4096. 

. 
Accepting keys with weak parameters (e.g. unusually small public exponent) or malformed but still treated as valid. 

. 
Missing duplicate-message suppression �C> replay acceptance. 

. 
Trusting unauthenticated USER_ADVERTISE . 


Prohibited: anything that escapes VM, exfiltrates real data, or harms the host. 

17. Sequence Diagrams 
These diagrams are to aid your understanding of the protocol. 
17.1.Bootstrap 


SERVER_HELLO_JOIN {host,port,pubkey} 

SERVER_WELCOME {assigned_id=2, servers=[S1]} SERVER_HELLO_LINK {host,port,pubkey} 


register server_2 link 



17.2.Direct Message (Bob �� Alice) 



MSG_PRIVATE {ciphertext, content_sig}  
USER_DELIVER {ciphertext,��}  
 
SERVER_DELIVER {user_id=Alice,ciphertext,��}  
USER_DELIVER {ciphertext,��}  
Verify sig, decrypt ciphertext  




18. Compliance Checklist 

RSA-4096 keys; RSA-OAEP (SHA-256) for encryption; RSASSA-PSS (SHA-256) for signatures. 

All
 user content carries content_sig (end-to-end). 


All
 server frames carry transport sig . 



USER_ADVERTISE /USER_REMOVE implemented. 

SERVER_DELIVER routing implemented with loop suppression. Heartbeats (15s) and 45s timeout. 


Error codes implemented. 

/list , /tell , /all , /file supported. 

READMEwith run commands and dependencies. 
19. Changelog 
Version  Changes  
v1.0  Initial proposal  
v1.1  . Use WebSockets instead of TCP . Addition of master database for users, profiles, and groups  
v1.2  . Added definitions section . Consolidated language and terminology . Added public channels and remove groups . Use UUIDs as unique identifiers for Users and Servers . Removed master database . Added more information on Server bootstrapping process . Added changelog section  
v1.3  . Replaced all AES-256-GCM encryption with RSA-4096 only. . Removed AES IVs, tags, and wrapped AES keys from Direct Messages, Public Channels, and File Transfers. . Updated content_sig handling to cover only RSA-encrypted payloads. . Updated compliance checklist, mandatory features, and diagrams to reflect RSA-only design.  



